# Технический контекст проекта "Нейросотрудник"

## Фаза 1: Анализ точки входа и зависимостей

### Шаг 1.1: Анализ зависимостей (`requirements.txt`)

-   **requests**: Для выполнения HTTP-запросов. Вероятно, для взаимодействия с какими-то внешними API.
-   **psycopg2**: Основной драйвер для работы с базой данных PostgreSQL.
-   **vk_api**: Для взаимодействия с API ВКонтакте.
-   **Flask**: Легковесный веб-фреймворк, вероятно, для обработки веб-хуков.
-   **openpyxl**: Для работы с файлами Excel (`.xlsx`).
-   **gunicorn**: WSGI-сервер для запуска Python-приложений в production.
-   **APScheduler**: Планировщик задач для фоновых процессов (например, напоминаний).
-   **google-cloud-aiplatform**: SDK для работы с Vertex AI (Gemini).
-   **pytz**: Для работы с часовыми поясами.
-   **google-oauth2-tool**: Для аутентификации в сервисах Google.

### Шаг 1.2: Анализ `Procfile`

-   **`web: gunicorn main:app ...`**: Команда подтверждает, что приложение запускается как веб-сервис с использованием Gunicorn на платформе **Railway**.
-   **Точка входа**: `main:app` указывает, что точкой входа является объект `app` в файле `main.py`, который, скорее всего, является экземпляром `Flask`.
-   **Production-конфигурация**: Используется 2 рабочих процесса (`--workers 2`), таймаут 180 секунд и предварительная загрузка приложения (`--preload`). Это говорит о готовности к обработке нескольких одновременных запросов в production-среде.

### Шаг 1.3: Детальный анализ `main.py`

#### 1.3.1. Инициализация и глобальные переменные

-   **Импорты**: `main.py` является центральным хабом, импортирующим все ключевые библиотеки: `flask` для веб-сервера, `vk_api` для взаимодействия с ВКонтакте, `psycopg2` для PostgreSQL, `requests` для HTTP-запросов, `APScheduler` для фоновых задач и `vertexai` для работы с ИИ. Также импортируются внутренние модули, например `reminder_service`.
-   **Загрузка конфигурации**: При старте скрипт загружает токены и ключи из переменных окружения, а также статичные данные из `knowledge_base.json` и `prompt.txt`.
-   **Глобальные переменные**: Скрипт активно использует глобальные переменные (`operator_timers`, `client_timers`, `dialog_history_dict`, `user_names`) для кеширования и управления состоянием диалогов в памяти.
-   **Асинхронность**: Для выполнения длительных операций без блокировки основного потока (обработки веб-хуков) используется `ThreadPoolExecutor`. В отдельные потоки выносятся сборка контекста и обновление саммари.

#### 1.3.2. Функции для работы с базой данных (PostgreSQL)

-   **`get_main_db_connection()`**: Централизованная функция для установки соединения с БД. Использует `DATABASE_URL` из переменных окружения.
-   **`get_user_name_from_db(user_id)`**: Получает имя пользователя из таблицы `user_profiles`. Применяет кеширование в глобальный словарь `user_names` для сокращения количества запросов к БД.
-   **`store_dialog_in_db(...)`**: Сохраняет каждое новое сообщение в таблицу `dialogues`.
-   **`fetch_and_update_vk_profile(...)`**: Обновляет профиль пользователя в таблице `user_profiles`, запрашивая актуальные данные из VK API.
-   **`update_conv_id_by_email(...)`**: Функция для мержа профилей, если в диалоге обнаруживается email, который уже есть в базе.
-   **Функции сборки контекста (`find_user_data_tables`, `fetch_data_from_table` и др.)**: Набор утилит для динамического поиска и извлечения всех связанных с пользователем данных из различных таблиц БД для последующей передачи в промпт.

#### 1.3.3. Обработчики веб-хуков (Flask)

-   **`/callback` (POST)**:
    -   **Назначение**: Основная и самая главная точка входа. Принимает все события от VK API (новые сообщения, подтверждение сервера и т.д.).
    -   **Логика**:
        1.  Проверяет тип события. Если это `confirmation`, возвращает специальный токен для подтверждения адреса сервера в VK.
        2.  Если это `message_new`, извлекает `user_id` и текст сообщения.
        3.  Вызывает основную функцию `handle_new_message`, передавая ей данные о сообщении.
        4.  Использует механизм отслеживания `event_id` для предотвращения повторной обработки одного и того же события.
        5.  Возвращает "ok", чтобы VK API знал, что событие получено.
-   **`/activate_reminder` (POST)**:
    -   **Назначение**: Позволяет внешнему сервису (вероятно, `reminder_service`) активировать отправку напоминания пользователю.
    -   **Логика**: Принимает `conv_id` и контекст напоминания. Запускает асинхронную задачу `_activate_reminder_async`, которая, в свою очередь, вызывает `generate_and_send_response` для формирования и отправки сообщения.
-   **`/clear_context/<int:user_conv_id>` (POST)**:
    -   **Назначение**: API для ручной очистки кеша и истории диалога для конкретного пользователя. Полезно для отладки.
    -   **Логика**: Удаляет данные о пользователе из глобальных словарей `dialog_history_dict`, `last_questions` и `user_buffers`.
-   **`/operator_message_sent` (POST)**:
    -   **Назначение**: Обрабатывает событие, когда оператор отправляет сообщение через интерфейс VK.
    -   **Логика**: Сбрасывает таймер `operator_timers`, который отслеживает, как долго оператор не отвечает. Это предотвращает отправку автоматических сообщений, если оператор уже включился в диалог.
-   **`/ping_main_bot` (GET)**:
    -   **Назначение**: Простой эндпоинт для проверки, что веб-сервис запущен и работает.
    -   **Логика**: Возвращает `{"status": "alive"}`.

#### 1.3.4. Ключевая логика ИИ и обработки сообщений

-   **`handle_new_message(...)`**:
    -   **Назначение**: Центральный оркестратор, вызываемый при получении нового сообщения.
    -   **Логика**:
        1.  Немедленно сохраняет входящее сообщение в БД (`store_dialog_in_db`).
        2.  Проверяет, не является ли сообщение от оператора. Если да, обработка прекращается.
        3.  Запускает `process_reminder_message` из `reminder_service`, чтобы обработать сообщение в контексте напоминаний.
        4.  Реализует механизм **буферизации сообщений**: если пользователь быстро пишет несколько сообщений подряд, они накапливаются в буфер и обрабатываются как одно целое через `USER_MESSAGE_BUFFERING_DELAY` секунд. Это позволяет ИИ получить более полный контекст перед ответом.
        5.  Если буферизация не требуется, немедленно вызывает `generate_and_send_response`.
-   **`generate_and_send_response(...)`**:
    -   **Назначение**: Формирует полный контекст, вызывает ИИ и отправляет ответ пользователю.
    -   **Логика**:
        1.  Асинхронно вызывает `build_context_sync` для сбора полного контекста из БД и `knowledge_base.json`.
        2.  Вызывает `generate_response` для получения текста ответа от модели Gemini.
        3.  Отправляет полученный ответ в VK с помощью `vk_api.messages.send`.
        4.  Асинхронно запускает `summary_updater.py` через `call_summary_updater_async` для обновления саммари диалога в фоне.
-   **`generate_response(...)`**:
    -   **Назначение**: Непосредственное взаимодействие с моделью Gemini.
    -   **Логика**:
        1.  Принимает текст вопроса, собранный контекст и системный промпт.
        2.  Формирует финальный промпт для модели.
        3.  Вызывает `model.generate_content(prompt)` для получения ответа.
        4.  Включает обработку ошибок и повторные попытки в случае сбоев API.
-   **`find_relevant_titles_with_gemini(...)`**:
    -   **Назначение**: "Умный" поиск по базе знаний. Перед основным запросом эта функция отправляет в Gemini вопрос пользователя и заголовки из `knowledge_base.json`, чтобы модель определила наиболее релевантные разделы. Это позволяет передавать в основной промпт только нужную информацию, экономя токены и повышая точность.
-   **`generate_summary_and_reason(...)`**:
    -   **Назначение**: Вызывается, когда пользователь просит позвать оператора.
    -   **Логика**: Отправляет в Gemini историю диалога с просьбой кратко summarizing (обобщить) её и предположить, почему понадобился оператор. Результат используется в уведомлении для оператора в Telegram.

## Фаза 2: Анализ ключевых сервисов

### Шаг 2.1: Анализ `summary_updater.py`

-   **Назначение**: Автономный фоновый сервис для поддержания актуальности и компактности данных по диалогам.
-   **Запуск**: Вызывается из `main.py` как отдельный процесс (`subprocess`), получая `conv_id` через `stdin`. Такая архитектура полностью изолирует его от основного приложения, предотвращая замедление обработки входящих сообщений.
-   **Ключевая механика**:
    1.  **Двойной вызов ИИ**: Скрипт делает два последовательных вызова к API Gemini:
        -   **Инкрементальное саммари (`PROMPT_INCREMENTAL_SUMMARY`)**: Обновляет общее саммари диалога, дописывая в него новую информацию из последних сообщений.
        -   **Извлечение фактов (`PROMPT_EXTRACT_NEW_FACTS`)**: Извлекает из **только что поступивших сообщений** структурированные данные (цели, боли, email, этап воронки и т.д.) в формате JSON.
    2.  **Слияние профилей (`merge_profiles`)**: Новые структурированные факты аккуратно "подмешиваются" к существующему профилю клиента в БД. Логика слияния предотвращает потерю данных (например, списки дополняются, а не перезаписываются).
    3.  **Атомарное обновление БД (`update_and_cleanup_database`)**:
        -   Все изменения записываются в базу данных в рамках одной транзакции для обеспечения целостности данных.
        -   Используется `SELECT ... FOR UPDATE` для блокировки строки профиля на время обновления, что предотвращает "гонки" данных.
        -   **Очистка истории**: После обновления скрипт удаляет все сообщения диалога, кроме последних `NUM_MESSAGES_TO_KEEP` (30), поддерживая компактность базы данных.

### Шаг 2.2: Анализ `reminder_service.py`

-   **Назначение**: Автономный сервис для автоматического анализа диалогов, создания и активации напоминаний о будущих контактах с клиентами.
-   **Два режима работы**:
    1.  **Реактивный (Real-time)**: `main.py` вызывает функцию `process_new_message(conv_id)` после каждого нового сообщения. Эта функция запускает анализ **конкретного диалога** на предмет установки нового напоминания.
    2.  **Проактивный (Фоновый)**: При старте `main.py` вызывает `initialize_reminder_service()`, которая запускает планировщик `APScheduler`. Планировщик раз в несколько минут проверяет все "сработавшие" напоминания и инициирует их активацию.
-   **Ключевая механика**:
    1.  **Анализ на постановку напоминания (`analyze_dialogue_for_reminders`)**: "Умная" часть сервиса. Отправляет последние сообщения диалога в Gemini с задачей найти договоренность о будущем контакте (например, "напишите мне завтра"). Если договоренность найдена, ИИ возвращает JSON с временем и текстом напоминания.
    2.  **Определение часового пояса (`detect_timezone_from_message`)**: Перед созданием напоминания сервис пытается определить часовой пояс клиента по упоминанию города в тексте или с помощью отдельного запроса к ИИ.
    3.  **Хранение**: Напоминания сохраняются в таблицу `reminders` в базе данных, время хранится в UTC.
    4.  **Активация с пре-валидацией (`check_and_activate_reminders`)**: Когда время напоминания наступает, сервис не отправляет его сразу. Он делает **превентивный вызов к ИИ**, чтобы тот проверил актуальность напоминания (например, если клиент уже написал сам, оно может быть отменено).
    5.  **Финальная активация**: Только после подтверждения от ИИ сервис делает POST-запрос на эндпоинт `/activate_reminder` в `main.py`, который уже инициирует отправку сообщения клиенту.
-   **Архитектурное решение**: Взаимодействие с `main.py` через API (`/activate_reminder`) является хорошим примером разделения ответственности между компонентами системы.

## Фаза 3: Анализ вспомогательных компонентов

### Шаг 3.1: Анализ `context_builder.py`

-   **Статус**: **Удален**. Функционал этого модуля был полностью перенесен в `main.py` для повышения производительности.
-   **Назначение (историческое)**: Изначально был отдельным сервисом, который собирал и форматировал контекст для ИИ.
-   **Текущее состояние**: Код из этого (теперь удаленного) файла полностью интегрирован в `main.py`. Анализ этого файла позволил полностью понять логику сборки контекста.

### Шаг 3.2: Анализ `prompt.txt` и `knowledge_base.json`

-   **`prompt.txt`**:
    -   **Назначение**: Это не просто промпт, а **конституция ИИ-ассистента**. Он определяет его личность ("Доверенный Партнёр"), стиль общения, цели, ограничения и рабочие процессы.
    -   **Ключевой компонент**: Раздел `<internal_analysis>` предписывает ИИ выполнять сложный мета-анализ перед каждым ответом, включая оценку психологического состояния клиента, стадии воронки и формирование краткосрочной/долгосрочной стратегии. Это превращает его из простого чат-бота в стратегического агента.
    -   **Содержит**: Подробную продуктовую матрицу (курсы, наборы, цены, ссылки на оплату) и правила предоставления скидок, что дает ассистенту коммерческие полномочия.
-   **`knowledge_base.json`**:
    -   **Назначение**: Статическая база знаний в формате "вопрос-ответ", служащая источником выверенной информации по десяткам типичных вопросов.
    -   **Содержит**: Ответы на вопросы о курсах, политиках школы, технических аспектах и т.д.
    -   **Взаимодействие**: `prompt.txt` напрямую указывает ИИ использовать эту базу как один из основных источников для формирования ответов, что обеспечивает их точность и консистентность.

-   **Общий вывод**: Связка `prompt.txt` (логика и личность) и `knowledge_base.json` (факты) является ядром "интеллекта" нейросотрудника.

## Фаза 4: Финальная документация и карта зависимостей

### Шаг 4.1: Анализ `performance_test.py`

-   **Примечание**: Этот файл был удален. Его описание сохранено для исторического контекста, так как оно объясняет ключевое архитектурное решение.
-   **Назначение**: Это был **нагрузочный тест и бенчмарк**, созданный для обоснования архитектурного перехода от синхронного вызова сборщика контекста к асинхронному вызову через `ThreadPoolExecutor`.
-   **Вывод**: Этот артефакт объяснял, почему логика сборки контекста была интегрирована в `main.py` — для решения проблемы производительности и обеспечения масштабируемости. 