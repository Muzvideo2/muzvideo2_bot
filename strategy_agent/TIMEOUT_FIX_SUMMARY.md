# Решение проблемы зависания скрипта анализа клиентов

## Проблема
Скрипт анализа клиентов завис на 3 часа при обработке клиента 10321177 на запросе к Gemini AI API. Последние логи показывали:

```
2025-08-29 16:55:34,801 - INFO - Отправка запроса к Gemini для анализа клиента 10321177
```

После этого скрипт перестал отвечать и висел бесконечно.

## Корень проблемы
Вызов `self.model.generate_content(prompt)` в методе `analyze_client_card()` не имел никаких ограничений по времени выполнения. Когда Vertex AI API не отвечал (возможно, из-за перегрузки или сетевых проблем), скрипт ждал ответа бесконечно.

## Реализованное решение

### 1. Добавлены константы тайм-аута и повторных попыток
```python
GEMINI_TIMEOUT_SECONDS = 180  # 3 минуты максимум на один запрос
MAX_RETRIES = 2  # Максимум 2 повторные попытки
RETRY_DELAY_SECONDS = 30  # Задержка между попытками
```

### 2. Создан декоратор тайм-аута (работает на Windows)
```python
def with_timeout(timeout_seconds):
    """Декоратор для ограничения времени выполнения функции (работает на Windows)"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            result = [None]  # type: List[Any]
            exception = [None]  # type: List[Optional[Exception]]
            
            def target():
                try:
                    result[0] = func(*args, **kwargs)
                except Exception as e:
                    exception[0] = e
            
            thread = threading.Thread(target=target)
            thread.daemon = True
            thread.start()
            thread.join(timeout_seconds)
            
            if thread.is_alive():
                # Поток все еще работает - произошел тайм-аут
                logging.error(f"[TIMEOUT] Функция {func.__name__} превысила лимит времени {timeout_seconds} секунд")
                raise TimeoutError(f"Операция превысила лимит времени {timeout_seconds} секунд")
            
            if exception[0] is not None:
                raise exception[0]
            
            return result[0]
        
        return wrapper
    return decorator
```

### 3. Создан отдельный метод для вызова Gemini с тайм-аутом
```python
@with_timeout(GEMINI_TIMEOUT_SECONDS)
def _call_gemini_with_timeout(self, prompt: str):
    """Вызов Gemini API с тайм-аутом"""
    if self.model is None:
        raise RuntimeError("Model not initialized")
    return self.model.generate_content(prompt)
```

### 4. Модифицирован основной метод анализа
Теперь метод `analyze_client_card()` включает:
- **Цикл повторных попыток**: До 3 попыток (1 основная + 2 повторные)
- **Тайм-аут для каждой попытки**: 3 минуты максимум
- **Задержка между попытками**: 30 секунд
- **Подробное логирование**: Каждая попытка логируется с номером
- **Graceful fallback**: При неудаче всех попыток возвращается базовый анализ

## Преимущества решения

1. **Нет более зависаний**: Максимальное время ожидания одного клиента = 3 попытки × 3 минуты + 2 задержки × 30 секунд = 10 минут
2. **Устойчивость к временным сбоям**: Если API временно недоступен, скрипт попробует еще раз
3. **Подробная диагностика**: Все тайм-ауты и ошибки подробно логируются
4. **Работает на Windows**: Использует threading вместо signal (который недоступен на Windows)
5. **Безопасность данных**: При сбое ИИ создается fallback-анализ, скрипт не крашится

## Как тестировать

Запустите тестовый скрипт:
```bash
cd strategy_agent
python test_timeout.py
```

Тест проверит:
- Работает ли тайм-аут (прерывает ли долгие операции)
- Работают ли нормальные операции (не прерывает ли короткие операции)

## Мониторинг в продакшене

Теперь в логах вы увидите:
```
[TIMEOUT] Используем тайм-аут 180 секунд
[GEMINI API ERROR] Попытка 1: Операция превысила лимит времени 180 секунд  
[RETRY] Ожидаем 30 секунд перед следующей попыткой...
[GEMINI FAILED] Все попытки исчерпаны
[FALLBACK] Создаём базовый анализ для клиента 10321177
```

## Рекомендации по настройке

Если проблемы с API продолжаются, можно:
1. Увеличить `GEMINI_TIMEOUT_SECONDS` до 300 (5 минут)
2. Увеличить `MAX_RETRIES` до 3
3. Увеличить `RETRY_DELAY_SECONDS` до 60 секунд

Но текущие настройки должны решить проблему зависания.